# Functions to handle https://doc.rust-lang.org/cargo/commands/cargo-metadata.html#output-format.


def _dependency_dict_to_struct(dep):
    return struct(
        name=dep["name"],
        source=dep["source"],
        req=dep["req"],
        kind=dep["kind"],
        rename=dep["rename"],
        optional=dep["optional"],
        uses_default_features=dep["uses_default_features"],
        features=dep["features"],
        target=dep["target"],
        registry=dep["registry"],
    )


def _target_dict_to_struct(target):
    return struct(
        name=target["name"],
        kind=target["kind"],
        crate_types=target["crate_types"],
        src_path=path(target["src_path"]),
        edition=target["edition"],
        required_features=target.get("required-features"),
        doctest=target["doctest"],
        test=target.get("test"),
    )


def rust_files_in_target(manifest_path, target):
    """
    Defined in https://doc.rust-lang.org/cargo/guide/project-layout.html.
    """
    crate_dir = manifest_path.parent()
    files = []
    bin_files = crate_dir.glob("src/bin/**/*.rs")
    for file in crate_dir.glob("src/**/*.rs"):
        if file not in bin_files:
            files.append(file)

    if target.src_path.filename() == "main.rs":
        files.extend(target.src_path.parent().glob("**/*.rs"))
    else:
        files.append(target.src_path)

    return set(files)


def rust_files_in_package(package):
    files = set()
    for target in package.targets:
        files += rust_files_in_target(package.manifest_path, target)
    return files


def _custom_honk_metadata(package):
    browser_tests = False
    metadata = package.get("metadata")
    if metadata:
        honk_metadata = metadata.get("honk")
        if honk_metadata and honk_metadata.get("browser-tests"):
            browser_tests = True

    return struct(
        browser_tests=browser_tests,
    )


def _package_dict_to_struct(package):
    dependencies = [_dependency_dict_to_struct(dep) for dep in package["dependencies"]]
    targets = [_target_dict_to_struct(target) for target in package["targets"]]

    return struct(
        name=package["name"],
        version=package["version"],
        id=package["id"],
        license=package["license"],
        license_file=package["license_file"],
        description=package["description"],
        source=package["source"],
        dependencies=dependencies,
        targets=targets,
        features=package["features"],
        manifest_path=path(package["manifest_path"]),
        metadata=package["metadata"],
        publish=package["publish"],
        authors=package["authors"],
        categories=package["categories"],
        keywords=package["keywords"],
        readme=package["readme"],
        repository=package["repository"],
        edition=package["edition"],
        links=package["links"],
        honk=_custom_honk_metadata(package),
    )


def _metadata_dict_to_struct(metadata):
    packages = dict()
    for raw_package in metadata["packages"]:
        package = _package_dict_to_struct(raw_package)
        packages[package.id] = package

    return struct(
        version=metadata["version"],
        root=metadata["workspace_root"],
        target_dir=metadata["target_directory"],
        member_ids=metadata["workspace_members"],
        packages=packages,
    )


def cargo_metadata(manifest):
    requested_version = 1  # only valid value at time of writing

    metadata_inputs = []
    # TODO make incremental globs more efficient and uncomment
    # metadata_inputs = manifest.parent().globs(
    #     # TODO figure out a better way to exclude target
    #     [
    #         "**/Cargo.toml",
    #         "**/Cargo.lock",
    #         "**/src/*.rs",
    #         "**/benches/**/*.rs",
    #         "**/examples/**/*.rs",
    #         "**/tests/**/*.rs",
    #     ]
    # )

    metadata_command = command(
        "cargo",  # TODO get this from a specified toolchain
        args=[
            "metadata",
            "--format-version",
            requested_version,
            "--manifest-path",
            manifest,
        ],
        inputs=metadata_inputs,
        outputs=[],
    )
    command_output = metadata_command.run().stdout()
    # TODO json.decode from starlark spec
    decoded = json_decode(command_output)
    metadata = _metadata_dict_to_struct(decoded)

    if metadata.version != requested_version:
        fail(msg="Got metadata v" + version + ", expected v" + requested_version)

    return metadata
